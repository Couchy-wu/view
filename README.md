[toc]

### Golang_coder_interview



#### Algo

##### 1.字符串

- [ ] 如何原地交换两个数
- [ ] 字符串之间保留一个空格之后将字符串翻转
- [ ] 找到字符串的最长无重复字符子串
- [ ] 最短回文串
- [ ] 最长回文子串长度
- [ ] 数组中重复的数据
- [ ] 1到n乱序排列的数据，少了其中一个，找出这个数
- [ ] 26进制字母求和
- [ ] 两个字符串最长公共子串
- [ ] ⼀个40亿的⽆序数字，请找出不存在的数字



##### 2.dp

- [ ] 盛最多水的容器
- [ ] 爬楼梯问题
- [ ] 接雨水
- [ ] 岛屿问题(高频)
- [ ] 力扣 221最大正方形
- [ ] 力扣 279 完全平方数 
- [ ] 力扣 70 爬楼梯
- [ ] 力扣 121 买卖股票的最佳时机
- [ ] 力扣 62 不同路径 
- [ ] 力扣 509 斐波那契数 



##### 3.数组

- [ ] 力扣 485 最大连续1的个数
- [ ] 力扣 283 移动零
- [ ] 力扣 27    移除元素
- [ ] 力扣 933 最近的请求次数
- [ ] 力扣 225  用队列实现栈
- [ ] 力扣 622 设计循环队列
- [ ] 力扣 641 设计循环双端队列
- [ ] 两个有序数组合并
- [ ] 两个有序数组合并，返回合并之后的中位数
- [ ] 数组中值出现了一次的数字
- [ ] 寻找两个升序数组的第K大值
- [ ] 无序数组找中位数
- [ ] 多数组 笛卡尔积，例：['s',['a', 'b'], [1, 2], 'x']，输出：[["s","a",1,"x"],["s","a",2,"x"],["s","b",1,"x"],["s","b",2,"x"]]
- [ ] ⼀个很⼤的List，⾥⾯都是int类型，如何实现加和？因为电⾯，就说了⼀下思路



##### 4.树

- [ ] 二叉树的右视图
- [ ] 二叉数中序遍历
- [ ] 判断二叉树是否为平衡二叉树
- [ ] 二叉树节点的公共祖先
- [ ] 二叉树的最大深度
- [ ] 通过中序遍历序列和先序序列恢复二叉树
- [ ] 二叉树的中序遍历和层次遍历
- [x] [二叉树的后续遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)



##### 5.排列

- [ ] 接口怎么设计，需要实现方实现什么
- [ ] 怎么调用这个通用的排序方法
- [ ] 全排列



##### 6.链表

- [ ] 力扣 206 反转链表 
- [ ] 力扣 203 移除链表元素
- [ ] 合并两个有序的单链表
- [ ] 链表奇递增 偶递减，整体递增
- [ ] 单链表逆序
- [ ] LRU缓存机制 （考虑并发访问）(高频) LRU实现--针对hash存储的方式，如何改进
- [ ] 单向链表排序
- [ ] 取单链表的倒数第K个结点
- [ ] ⼀个链表，输⼊k，⽐如k=3，翻转前3个链表值



##### 7.hash

- [ ] 字符串hash算法的实现
- [ ] 敏感词过滤
- [ ] 力扣 217 存在重复元素
- [ ] 力扣 389 找不同
- [ ] 力扣 496 下一个更大的元素





##### 8.other

- [ ] 25匹马，每次只能比赛5组，最快几次找到前3名



##### 9.海量数据处理

- [ ] hash
- [ ] 字典树
- [ ] bitmap
- [ ] 布隆过滤器
- [ ] MapReduce
- [ ] 桶
- [ ] 亿级数据，每一行两列，如何按照第一列升序 第二列降序排列？数据分布不均或较为集中的情况又如何处理更好？
- [ ] 几十亿行数据，记录当天的抖音用户 uid 登录时间 登出时间 如何计算出日活峰值在哪个时间（精确到秒），以及持续了几秒。



##### 10. 栈

- [x] 力扣 20 有效的括号
- [ ] 力扣 496 下一个更大的元素 
- [ ] 力扣 232 用栈实现队列



##### 11.集合

- [ ] 力扣 217 存在重复元素
- [ ] 力扣 705 设计哈希集合



##### 12.堆

- [ ] 力扣 215 数组中的第K个最大元素
- [ ] 力扣 692 前K个高频单词



##### 13.双指针算法

- [ ] 力扣 141 环形链表
- [ ] 力扣 344 反转字符串
- [ ] 力扣 881 救生艇



##### 14.二分查找法

- [ ] 力扣 704 二分查找
- [ ] 力扣 35 搜索插入位置
- [ ] 力扣 162 寻找峰值
- [ ] 力扣 74 搜索二维矩阵



##### 15.拓扑排序

- [ ] 力扣 210 课程表 II 
- [ ] 力扣 207 课程表



##### 16.Trie(前缀树)

- [ ] 力扣 208 实现Trie
- [ ] 力扣 720 词典中最长的单词
- [ ] 力扣 692 前K个高频单词



##### 17.滑动窗口

- [ ] 力扣 209 长度最小的子数组
- [ ] 力扣 1456 定长子串中元音的最大数目



##### 18.递归算法

- [ ] 力扣 509  斐波那契数
- [ ] 力扣 206 反转链表
- [ ] 力扣 344 反转字符串
- [ ] 力扣 687 最长同值路径



##### 19.分治算法

- [ ] 力扣 169 多数元素
- [ ] 力扣 53 最大子序和



##### 20.回溯算法

- [ ] 力扣 22 括号生成
- [ ] 力扣 78 子集
- [ ] 力扣 77 组合
- [ ] 力扣 46 全排列



**深度优先算法 DFS**

| 力扣 938 | 二叉搜索树的范围和 \| Range Sum of BST |
| -------- | -------------------------------------- |
| 力扣 78  | 子集 \| Subsets                        |
| 力扣 200 | 岛屿数量 \| Number of Islands          |



**宽度优先算法 BFS**

| 力扣 102 | 二叉树的层序遍历 \| Binary Tree Level Order Traversal       |
| -------- | ----------------------------------------------------------- |
| 力扣 107 | 二叉树的层序遍历 II \| Binary Tree Level Order Traversal II |
| 力扣 200 | 岛屿数量 \| Number of Islands                               |



**并查集 Union Find**

| 力扣 200 | 岛屿数量 \| Number of Islands   |
| -------- | ------------------------------- |
| 力扣 547 | 省份数量 \| Number of Provinces |
| 力扣 721 | 账户合并 \| Accounts Merge      |



**贪心算法 Greedy**

| 力扣 322  | 零钱兑换 \| Coin Change                                   |
| --------- | --------------------------------------------------------- |
| 力扣 1217 | 玩筹码 \| Minimum Cost to Move Chips to The Same Position |
| 力扣 55   | 跳跃游戏 \| Jump Game                                     |



**记忆化搜索 Memoization**

| 力扣 509 | 斐波那契数 \| Fibonacci Number |
| -------- | ------------------------------ |
| 力扣 322 | 零钱兑换 \| Coin Change        |





#### Redis

##### 1.数据结构

- [ ] zset的底层实现
- [ ] redis incr实现
- [ ] Redis 3.1 都⽤过哪些数据类型？分别介绍下使⽤场景？



##### 2.使用场景

- [ ] 分布式锁

  ##### 实现:

  ​	 单节点：`SET resource_name my_random_value NX PX 30000`

  > ​     该命令仅当 Key 不存在时（NX保证）set 值，并且设置过期时间 3000ms （PX保证），值 my_random_value 必须是所有 client 和所有锁请求发生期间唯一的

  释放锁：

     

  ```lua
  if redis.call("get",KEYS[1]) == ARGV[1] then
      return redis.call("del",KEYS[1])
  else
      return 0
  end
  ```

  

  > 上述实现可以避免释放另一个client创建的锁，如果只有 del 命令的话，那么如果 client1 拿到 lock1 之后因为某些操作阻塞了很长时间，此时 Redis 端 lock1 已经过期了并且已经被重新分配给了 client2，那么 client1 此时再去释放这把锁就会造成 client2 原本获取到的锁被 client1 无故释放了，但现在为每个 client 分配一个 unique 的 string 值可以避免这个问题。至于如何去生成这个 unique string，方法很多随意选择一种就行了。

  ##### Redlock算法描述

  1. 获取当前时间（毫秒数)；

  2. 尝试顺序地在 N 个实例上申请锁，当然需要使用相同的 key 和 random value，这里一个 client 需要合理设置与 master 节点沟通的 timeout 大小，避免长时间和一个 fail 了的节点浪费时间；

  3. 当 client 在半数以上的实例成功申请到锁的时候，且它会计算申请锁消耗了多少时间，这部分消耗的时间采用获得锁的当下时间减去第一步获得的时间戳得到，如果锁的持续时长（lock validity time）比流逝的时间多的话，那么锁就真正获取到了；

  4. 如果锁申请到了，那么锁真正的 lock validity time 应该是 origin（lock validity time） - 申请锁期间流逝的时间；

  5. 如果 client 申请锁失败了，那么它就会在少部分申请成功锁的 master 节点上执行释放锁的操作，重置状态。

     ##### 一些细节

     ###### 非同步的时钟

     > 由于 Redlock 算法中使用的各个实例没有同步的时钟，而且每个机器时钟可能也不准，简单的做法是对步骤 3 中的时间再减去一小段时间，从而缓解实际中各个机器间的时钟偏移（Clock Drift）。

     ###### 失败重试

     > 如果一个 client 申请锁失败了，那么它需要稍等一会在重试避免多个 client 同时申请锁的情况，最好的情况是一个 client 需要几乎同时向 N个 实例 发起锁申请。另外就是如果 client 申请锁失败了它需要尽快在它曾经申请到锁的 实例上执行 unlock 操作，便于其他 client 获得这把锁，避免这些锁过期造成的时间浪费，当然如果这时候网络分区使得 client 无法联系上这些 实例，那么这种浪费就是不得不付出的代价了。

     ###### 性能、故障恢复和 fsync

     > 假设 Redis 没有持久性，当一个客户端获得了 5 个实例中的 3 个锁，若 3 个锁所在的实例 Down 掉了，实例再次启动时，其他的客户端也可以再次获得锁。
     >
     > 这个问题会因为开启了 Redis 的持久化而改观，对于 AOF 持久化（区别与 RDB 的二进制持久化，是文本持久化）。默认采用的是每秒钟通过 `fsync` 落盘，这意味着会丢失一秒内的数据，如果需要更有安全保证的持久化，可以设置 `fsync=always`，但对应的会损失一部分性能。
     >
     > 更好的解决办法是在实例 Down 掉后延迟一个略长于锁合法时间的时间，这样就可以保证在实例启动起来时锁一定是过期的，从而无须以损失性能为代价而使用 `fsync=always` 的持久化。

     ###### 锁续约

     > Topic 中还提出了一个锁续约的概念，即客户端可初始时使用较小的锁有效时间，若时间超时仍操作仍未完成则通过 Lua 脚本来续期。
     >
     > 续约操作同获取锁的操作，如果能从多数的 Redis 实例中续约，则认为锁续约成功。
     >
     > 为了保证锁最终可以被释放，续约操作存在着一定的次数限制。

     ###### 释放锁

     > 放锁操作很简单，就是依次释放所有节点上的锁就行了

  ##### Redlock 相关的讨论

  > 针对 Redlock 的安全性问题，[Martin Kleppmann](http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html) 与作者 [antirez](http://antirez.com/news/101) 存在着一些争论。

  ###### Redlock 存在的问题

  > Martin Kleppmann 提出使用分布式锁有两种目的：效率和正确性。

  ###### 效率

  > 效率相关的应用主要在使得同一个运算不会被同时计算两次，如果在这种情况下使用多个实例的分布式锁，不如使用单机分布式锁实现。由于误判仅会增加计算量而并不影响正确性，所以可以使用 Master Slave 的方式来增加可用性。

  ###### 正确性

  > 正确性相关的质疑在两个方面：
  >
  > 1. 由于无法保证锁在操作结束前一定不会结束，可能无法意识到自己的锁失效了，会导致同时有多个客户端持有锁并进行操作。
  > 2. 基于时间的假设是不可靠的。
  >
  > 针对第二点，Martin 举了两个例子，以下均以 5 个节点 A ~ E 和 2 个客户端为例。
  >
  > 1. Redis 实例的时间无法保证不被修改，时间的修改可能导致锁的过期和异常：
  >    1. 客户端 1 从节点 A、B、C 上获取锁，节点 D、E 由于网络原因不可达。
  >    2. 节点 C 的时间跳变，锁过期了。
  >    3. 客户端 2 从节点 C、D、E 上获取了锁，由于网络原因，节点 A、B 不可达。
  >    4. 客户端 1、2 均认为它们拥有了锁。
  > 2. 即使时间不会跳变，进程停等也可能影响正确性：
  >    1. 客户端 1 从节点 A、B、C、D、E 上获取了锁。
  >    2. 当请求快抵达客户端 1 时，客户端 GC 进行了 stop-the-world 操作。
  >    3. 所有实例上的锁都过期了。
  >    4. 客户端 2 从节点 A、B、C、D、E 上获取了锁。
  >    5. 客户端 1 GC 结束了，同时获取了之前的请求信息。
  >    6. 客户端 1、2 均认为它们拥有了锁。
  >
  > Martin 提出使用一种小 trick，使用类似的递增 ID 作为 fencing token 来保证每次锁内操作的正确性。在客户端每次请求中会检查 fencing token，如果依赖的是旧的 token，那么此操作会被拒绝并提示。
  >
  > Martin 认为 Redlock 是一个 [asynchronous model with unreliable failure detectors](http://courses.csail.mit.edu/6.852/08/papers/CT96-JACM.pdf)，依赖了不可靠的元素来保证其一致性，容错存在一个限度，超过限度则无法保证其正确性。GC 的 stop-the-world、网络的阻塞、换页等都会影响 Redlock 的效率或者正确性。
  >
  > Martin 的结论是：如果仅是效率需求，使用单节点算法；如果需求正确性，通过 zookeeper 来实现锁，或者使用 fencing token 来保证安全性。

  ###### 解释和改进

  > antirez 解释了目的是为了让人们找到单节点或者主备锁的替代品，从而在复杂度低以及高效的前提下使用锁。
  >
  > 针对正确性的第一点质疑，即锁内可能超时，antirez 认为分布式锁并不能提供强一致性的保证，只在没有别的办法控制共享资源时才会使用。
  >
  > 针对正确性的第二点质疑，对于第一个例子，提出 NTP 和手动修改时间导致的时间过大跃迁都可以被人工避免，其次也提出可以使用单调时间 API 来进行改进（不过好像至今没有更新）；对于第二个例子，实际出现次数非常少，另可以通过在获取到锁之后检查获取锁之前后的本地时间来确定锁是否过期。
  >
  > 对于 fencing token，若操作之间存在着线性关系，则可更改为递增 id；如果没有线性关系，则可以每次操作前检查 Key 对应的随机 Value 来避免过期操作。

  非常建议看下https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html 这篇文章。

  翻译版 https://juejin.cn/post/6844904039218429960

  ##### 分布式锁可能遇到问题：

  1、锁误解除

  > 如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。

  2、超时解锁导致并发

  > 如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。

  上述问题 解决办法：

  > - 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。
  > - 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。

  

- [ ] 缓存雪崩、缓存击穿、缓存穿透

- [ ] 

- [ ] reids的大key

- [ ] 热key的处理

- [ ] redis大key会有什么问题，如何解决

- [ ] redis超时是什么引起的

- [ ] redis缓存穿透,缓存雪崩





##### 3.架构

- [ ] redis是单线程的吗
- [ ] redis底层网络原理
- [ ] redis为什么速度比较快
- [ ] redis的发布/订阅的原理
- [ ] 数据缓存过期策略
- [ ] redis内存淘汰策略（说说 redis 中到期删除是怎么实现的）
- [ ] redis 的删除策略。定时 定期 惰性 lru(LRU高频)
- [ ] 持久化策略及其对比:RDB和AOF区别，AOF重写（如果数据量比较大都可能会造成redis 抖动）
- [ ] 持久化机制，AOF、RDB具体区别有哪些？ 
- [ ] redis主从复制过程
- [ ] Redis 主从同步机制是怎么样的，⽐如slave启动之后同步过程？
- [ ] redis的部署模式
- [ ] Redis Cluster集群如何选主的？
- [ ] Redis Cluster 跟哨兵模式有什么区别吗？ 
- [ ] Sentinel 哨兵模式是如何选主的？
- [ ] redis哨兵选leader过程、槽相关、redis-cluster和codis扩展
- [ ] 这⾥说跟cluster差不多，追问了下，其实还是有些区别的， sdown odown 主观宕机、客观宕机⽅式不太⼀样





#### MySQL

##### 1.索引

- [ ] 如果Innodb没主键怎么办？
- [ ] 对 a b c 建索引，找 b c 时会不会走索引？ 精准找 a 范围 b 精准 c 呢？
- [ ] MySQL为什么是B + 树的结构，为什么不能是红⿊树呢？优化的是什么，优化的是磁盘IO，减少磁盘寻址。
- [ ] innodb的B+树原理，如何做页分裂和页合并？查询时间复杂度？
- [ ] 为什么选择B+树实现索引？一般深度为多少？b+树和红黑树的区别?(高频)
- [ ] MySQL数据库底层实现结构？B+树结构，也讲了数据⻚，以及⻚⽬录相关的
- [ ] 创建索引后，查询读取I/O的次数
- [ ] 索引的分类
- [ ] 聚簇索引和非聚簇索引区别？如何避免回表查询？
- [ ] 聚簇索引和非聚簇索引的区别
- [ ] 创建索引后，查询读取I/O的次数
- [ ] 索引的最左前缀原则
- [ ] mysql数据的索引优化以及失效
- [ ] 联合索引怎么存储？
- [ ] 覆盖索引相关问题
- [ ] 假设有⼀个表字段⼏⼗个，索引如何创建的？所有字段都能建吗？区分度、选择性、列基数

##### 2.锁

- [ ] 数据库中的乐观锁悲观锁
- [ ] 排他锁(x锁)
- [ ] 什么是死锁，如何避免
- [ ] mysql的隔离级别？处理什么问题的（脏读、幻读、不可重复读）(高频)
- [ ] 间隙锁坏处，如何避免
- [ ] 说说这些间隙锁的底层实现 ( 我真的学不动了 )


##### 3.日志

- [ ] undo log
- [ ] redo log
- [ ] binlog

##### 4.架构

- [ ] mysql的主从复制过程？
- [ ] mysql的大表优化方式

##### 5.事务

- [ ] 数据库的ACID原理和各个隔离级别，实现原理？
- [ ] Innodb 默认是哪个隔离级别
- [ ] 说说 innodb 如何避免各种读的
- [ ] 说说 mvcc 的底层实现

##### 6.SQL

- [ ] 从学生表中查询每个班的分数的前3名
- [ ] 写一条sql统计， 统计当天访问量前10的ip ip visit_time url 102.12.12.1 2020-03-25 10:10:10 



#### MQ

##### 1.设计相关

- [ ] kafka使用场景
- [ ] Kafka如何保证消息可靠,Kafak为什么那么快
- [ ] Kafka 4.1 ⽣产端是如何发送⼀条消息到Broker的？
- [ ] 4.2 具体可以调整哪些参数提升吞吐量？
- [ ] 4.3 消费端发⽣rebalance的过程是怎样的？
- [ ] ⽐如有⼀个新的consumer加⼊ 到了Group中是个什么流程？
- [ ] RabbitMQ如何保证⾼可⽤的？queue数据在节点之间如何同步的？死信队列 如何实现的？
- [ ] kafka的offset怎么管理
- [ ] 消息队列消费端的推和拉有什么区别
- [ ] MQ队列⽤了哪些，Kafka，那⾦融场景下，Kafka如何保证消息不丢失？ack = -1，Leader-->ISR写⼊所有的follower



#### Network

##### 1.TCP/UDP

- [ ] TCP和UDP的区别,TCP三次握手？SEQ 是干什么的？两次握手行不行？　TCP Fast Open了解么,TCP的拥塞控制是怎么做的
- [ ] tcp 拥塞策略(高频)(RBB)
- [ ] tcp协议栈中TIME_WAIT字段的作用(高频) https://mp.weixin.qq.com/s/8WmASie_DjDDMQRdQi1FDg
- [ ] tcp的和colse_wait状态
- [ ] 如何解决tcp的粘包问题，tcp的拆包粘包怎么处理？为什么会有TIME_WAIT？ (自定以协议中包含 包体长度)
- [ ] 如何理解网络模型(重点epoll , select 的区别。 实现非阻塞 connect， 使用select)
- [ ] tcp的send函数返回一定代表数据从网卡发送出去了么？我说只是发送到了内核缓冲区。又问这个缓冲区也是属于该进程的么？回答是。又继续问，一个数据接收过程发生了几次用户态到内核态的拷贝？

##### 2.DSN

- [ ] 说说CDN的架构，缓存的实现, 用户的访问流程，调度是怎么选择机房的
- [ ] DSN 查询过程,递归查询和迭代查询的区别

##### 3.HTTP

- [ ] HTTP协议的发展,HTTP缓存实现方式，跟HTTP缓存相关的头部字段，HTTP 302了解么
- [ ] HTTP和HTTPS有什么区别、HTTPS的访问流程、CA中心是什么，确定加密协议过程
- [ ] http的状态码含义：502 504区别 301 302区别，分析一下系统 502 和504 可能的原因(线上各类排错)
- [ ] http2的优势
- [ ] http header有哪些部分
- [ ] 长连接 http长连接和websocket对比
- [ ] 长轮询和短轮询了解吗
- [ ] rpc和http优劣

##### 4.其他

- [ ] session cookie区别，分别存哪里？跨域问题如何解决





#### System

- [ ] 进程、线程和协程的区别？ 
- [ ] 栈和堆的特点？那个效率更高效？
- [ ] 进程间通信方式？哪种方式最快？为什么共享内存要比socket快？
  我说了共享内存最快，面试官接着问为什么比socket快，我说了socket走网络，面试官继续问，要是本地回环呢？我想到socket涉及到用户态内核态数据拷贝，而共享内存采用mmap就可以。
- [ ] 线程间通信方式有哪些？线程通信跟线程同步有何区别？
- [ ] Linux最基本的两个锁是什么？说一下各自的特点

#### Nginx

- [ ] nginx反向代理怎么配置
- [ ] nginx平滑重启什么原理



#### Your project



#### Golang

##### 1. 并发

- [ ] sync.map、sync.pool、sync.once 的原理
- [ ] sync.pool 如果采用该方案实现连接池，会不会出现连接断开情况？

##### 2.底层原理

- [ ] goroutine(协程)和线程是什么关系，goroutine是如何调度的？

  

  1. goroutine 和thead 之间的区别
     1. 概念上：
        1. Goroutines 在同一个用户地址空间里并行独立执行 functions
        2. thread 则是操作系统能够进行运算调度的最小单位
     2. 内存上:
        1. 创建一个 goroutine 的栈内存消耗为 2 KB(Linux AMD64 Go v1.4后)，运行过程中，如果栈空间不够用，会自动进行扩容
        2. 创建一个 thread 为了尽量避免极端情况下操作系统线程栈的溢出，默认会为其分配一个较大的栈内存( 1 - 8 MB 栈内存，线程标准 POSIX Thread)，而且还需要一个被称为 “guard page” 的区域用于和其他 thread 的栈空间进行隔离。而栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出的风险
     3. 销毁时：
        1. goroutine 可以理解为用户态级别的线程，由go runtime 进行管理，销毁成本较低
        2. thread 销毁则需要进行内核级交互， 成本较高
     4. 调度时：
        1. goroutine切换完全在用户空间进行，相比线程切换做的事情更少
        2. 线程切换涉及特权模式切换，需要在内核空间完成
     5. 具体：
        1. 协程切换只涉及基本的CPU上下文切换，所谓的 CPU 上下文，就是一堆寄存器，里面保存了 CPU运行任务所需要的信息：从哪里开始运行栈顶的位置，当前栈帧在哪，以及其它的CPU的中间状态或者结果。goroutine 切换就是把当前的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上就 ok 了
        2. 而线程的调度只有拥有最高权限的内核空间才可以完成，所以线程的切换涉及到用户空间和内核空间的切换，除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等。
        3. 扩展问题， 可能会涉及到 操作系统中的 什么是用户态和内核态，还有就是系统调度？
           1.  用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。
           2.  内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。
           3.  系统调度：这是用户态进程主动要求切换到内核态的一种方式。
               1. 协程切换只涉及基本的CPU上下文切换，所谓的 CPU 上下文，就是一堆寄存器，里面保存了 CPU运行任务所需要的信息：从哪里开始运行
                  栈顶的位置，当前栈帧在哪，以及其它的CPU的中间状态或者结果。goroutine 切换就是把当前的 CPU 寄存器状态保存起来，
                  然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上就 ok 了；
               2. 而线程的调度只有拥有最高权限的内核空间才可以完成，所以线程的切换涉及到用户空间和内核空间的切换，除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等。
                  扩展问题， 可能会涉及到 操作系统中的 什么是用户态和内核态，还有就是系统调度？ 
                  用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。
                  内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。参考链接 https://www.cnblogs.com/gtblog/p/12155109.html https://www.zhihu.com/question/308641794

- [ ] go gmp 调度模型实现。从早期1.x版本演进到1.14，做了哪些大改变? time.sleep阻塞时,网络请求阻塞时,调用系统方法时,GMP怎么流转的？

- [ ] 谁负责来标记抢占? 有如下代码 go func(){ for{}}() 死循环，能否被抢占?1.14版本前会有什么问题？

- [ ] go 调度模型。发生网络io.会怎么调度。发生阻塞的IO会怎么调度。epoll

- [ ] select和epoll的区别

- [ ] 如何控制goroutine并发数？

- [ ] for(i<1000000;i++){go fun(){ …time.sleep（10秒）}()} 同时启动100万协程。会有什么问题?影响面: 如(gc 检查,死锁检查) 怎么解决?

- [ ] 是否有必要使用协程池?好坏处?举个使用场景

- [ ] 实现一个并发模型。生产者消费者

- [ ] go 读写锁和互斥锁的区别和使用场景

  1. sync.RWMutex ：由Mutex + atomic 实现, sync/rwmutex.go 

     特点：抢占式读写锁，写锁之后，读锁加不上；

  2. 写写时需要引入Mutex 
     注意点：知道读写锁 纯读或者 读多写少的情况下，性能差别不是太大，大概几倍，在一些场景下，可以考虑使用Mutex代替RWMutex, 毕竟RWMutex 编码还是比较复杂的。相信我多数面试官没有压测过。

- [ ] chan 底层实现 、 make(chan struct {}) 和 make(chan bool) 在chan的源码实现上有什么区别，chan，什么时候会panic

  1.  循环队列+mutex（注意下 no buffer 的在读取时的优化，其他大概回答下 ）；make(chan, 1) 和make(chan) 的区别 。 顺便可以说下channel 的优雅关闭 
     注意点：在有等待的receiver 时，发送方会越过channel buffer 直接将数据copy 到receiver 。
     源码解析 参考 https://github.com/cch123/golang-notes/blob/master/channel.md
  2. 第二个问题: 大概是问struct{} 在go内部做了优化，不占用内存；其他类型(int, bool, ptr)都需要64位(bool 待定)。可以不具体回答字节数
  3. chan，什么时候会panic
     write to close(chan)

- [ ] 有缓冲channel和无缓冲channel区别？

- [ ] map 底层实现&sync.Map的区别

   	1. 原理参考：https://tonybai.com/2020/11/10/understand-sync-map-inside-through-examples/
   	源码解析: https://github.com/cch123/golang-notes/blob/master/sync.md

- [ ] golang 的map 插入顺序和输出顺序是一样的吗？

  随机输出， 原因 考虑map 扩容时，原来同一个bucket 的key，扩容后，有可能落到其他位置上。

- [ ] go内存分配

- [ ] go 内存分配，大小对象内存分配区别？多级分配的优点是什么？

- [ ] go内存泄漏

   	1. 内存泄漏场景： https://gfw.go101.org/article/memory-leaking.html 
   	有兴趣可以看下这个： https://xargin.com/logic-of-slice-memory-leak/

- [ ] 内存对齐，说说为什么要内存对齐，原理原因

  1. 原因：比如 intel 32位cpu，每个总线周期都是从偶地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据，因此需要在内存中存放数据时进行对齐。参考https://www.zhihu.com/question/27862634

- [ ] go gc的实现与触发机制

   	1. 实现： https://github.com/yifhao/share/blob/master/gopher%20meetup-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAGolang%20Runtime-yifhao-%E5%AE%8C%E6%95%B4%E7%89%88.pdf
   	2. 触发：
   	 	1. 主动触发 通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕；
   	 	2. 被动触发，分为两种方式：
   	     使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。
   	     使用步调（Pacing）算法，其核心思想是控制内存增长的比例。

- [ ] interface 底层实现，怎么判空？

  

  1. 底层实现

     1. 接口有两种底层结构,分别是：`iface` 和 `eface` ，区别在于 `iface` 描述的接口包含方法，而 `eface` 则是不包含任何方法的空接口：`interface{}`。
     2.  `iface` 内部维护两个指针，`tab` 指向一个 `itab` 实体， 它表示接口的类型以及赋给这个接口的实体类型。`data` 则指向接口具体的值，一般而言是一个指向堆内存的指针。`_type` 字段描述了实体的类型，包括内存对齐方式，大小等；`inter` 字段则描述了接口的类型。`fun` 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab
     3. ![](https://raw.githubusercontent.com/ShadowStorm97/cloudimg/main/image-20210306153606436.png)
     4. ![](https://raw.githubusercontent.com/ShadowStorm97/cloudimg/main/image-20210306153634432.png)
     5. `interfacetype` 类型，它描述的是接口的类型，它包装了 `_type` 类型，`_type` 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 `mhdr` 字段，表示接口所定义的函数列表， `pkgpath` 记录定义了接口的包名
     6. ![](https://raw.githubusercontent.com/ShadowStorm97/cloudimg/main/image-20210306153933648.png)
     7. 看下 `_type` 结构体，Go 语言各种数据类型都是在 `_type` 字段的基础上，增加一些额外的字段来进行管理的
     8. ![](https://raw.githubusercontent.com/ShadowStorm97/cloudimg/main/image-20210306154445739.png)
     9. ![](https://raw.githubusercontent.com/ShadowStorm97/cloudimg/main/image-20210306154550415.png)

  2. 接口判空

     **接口值的零值是指`动态类型`和`动态值`都为 `nil`。**当仅且当这两部分的值都为 `nil` 的情况下，这个接口值就才会被认为 `接口值 == nil`

  3. 接口小技巧

     1. *编译器自动检测类型是否实现接口* , `` var _ io.Writer = (*myWriter)(nil) `` ,赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。

- [ ] slice的底层实现

  

  1. slice 是一个结构体，包含三个字段：长度、容量、底层数组。

  2. 底层数据结构是数组，slice 是对数组的封装，它描述一个数组的片段,可以通过下标来访问单个元素。

  3. ![](https://raw.githubusercontent.com/ShadowStorm97/cloudimg/main/image-20210306160532172.png)

  4. slice在进行append的时候,如果容量不够,会发生扩容,通常情况下,将新的容量将扩大为原始容量的2倍。如果原先的容量超过1024,则按1.25倍来进行扩容。 slice 是一个结构体，包含三个字段：长度、容量、底层数组。底层数据结构是数组，slice 是对数组的封装，它描述一个数组的片段,可以通过下标来访问单个元素。

  5. slice在进行append的时候,如果容量不够,会发生扩容,通常情况下,将新的容量将扩大为原始容量的2倍。如果原先的容量超过1024,则按1.25倍来进行扩容。

  6. **小TIPS**：**在对slice进行扩容的时候,由于做了内存对齐的操作,实际容量是要大于1.25倍的**

     

- [ ] slice 和 array的区别？

  

  1. 相同点:

     1. 都可以通过下标访问

  2. 不同点:

     1. 数组元素个数固定不能修改,slice元素个数不固定

     2. 切片可以扩容

     3. 初始化方法不一样，切片使用make创建

        

- [ ] []byte{} string 的区别

  

  1. string底层结构为指向byte数组的指针+len
  2. byte切片可以改变元素,而string由于底层是数组,无法修改
  3. 对string的修改操作需要重新开辟内存,旧数组会被GC回收,有性能问题

  

- [ ] new和make的区别(高频)

  1. new返回的是指向type的指针,指向分配类型的内存地址;make直接返回的是type类型值
  2. new只有一个type参数，type可以是任意类型数据; make可以有多个参数，但是只能是slice，map，或者chan
  3. new返回的指针指向的地址值为类型的0值;make返回的是非零值的实例

- [ ] reflect 的使用

  

- [ ] map 底层实现sync.Map的区别

  1. Map底层实现
     1. 
  2. sync.Map的底层实现
     1. 
  3. 区别
     1. 

- [ ] Context 的使用，用法，有无父子关系？怎么去做并发控制？底层实现（高频）

  ​	

- [ ] context 的使用，context是否并发安全？

- [ ] defer关键字的作用, 多个defer的调用顺序？

- [ ] go panic 的机制。defer,recover的结合使用（golang的panic怎么理解，怎么处理，recover 一般怎么处理）

- [ ] 讲一下Golang 空结构体

- [ ] go timer底层的实现 . 时间调度可以用哪些数据结构来实现?( 如 回答 时间轮: nginx 。最小堆: go timer 链表等 )

- [ ] init函数如何使用？

- [ ] go 性能问题的定位( pprof,各项指标)

- [ ] 逃逸分析能做什么？如何进行逃逸分析？

- [ ] go gc的实现与触发机制

- [ ] go 内存分配

#### design

- [ ] 如何设计一个秒杀系统
- [ ] trace了解吗
- [ ] 实时战力前100排行榜怎么设计(考察redis 使用)
- [ ] rank系统怎么设计
- [ ] 有10亿用户，让你设计一个社区架构。包括点赞 发帖 删帖 的积分架构、期间一直在追问设计合不合理
- [ ] 给你1亿个URL 。爬取信息。会遇到什么问题？从 CPU 磁盘 网络 等方面。这个聊了很多。
- [ ] 描述 推送架构设计 
- [ ] 线上熔断降级怎么做的
- [ ] 全站Push 的 运营误操作如何防止
- [ ] 亿级帖子，对应的评论表如何设计
- [ ] 设计一个短连（一个长的url地址，转为一个短的）
- [ ] 设计一个高可用的稳定的并发模型处理HTTP请求
- [ ] 一致性hash算法
- [ ] 限流策略
- [ ] 高并发的生产者消费者模式
- [ ] 编码过程中你比较注意哪一些
- [ ] 你负责的系统中，你一般关注哪些点，怎么保证你关注的点不出问题
- [ ] 实现MapReduce中的Map,例如: cat file.txt | ./go-reader　-cmd "${cmd} " > result.txt
  - go-reader为接受cat file.txt的输入lines，将lines给${cmd}处理，最后输出结果
  - 进程间怎么通信，go-reader要考虑协程池吗，为什么
- [ ] 不用定时任务的方式，实现一条消息定时发送或者任务到点执行
- [ ] 说说定时任务系统怎么做的，什么是一个任务，一个任务的生命周期是什么样的
- [ ] 设计一个高并发、高可用的架构
  - 读比较多怎么设计
  - 写比较多怎么设计
  - 服务的负载均衡怎么做
  - MySQL 怎么部署，读写分离怎么做
  - MySQL索引是什么,什么数据结构，MyISAM与InnoDB索引的区别，假设有一张表，有a,b两个索引，索引会怎么选择？(a,b) 是联合索引时会怎么选择
  - MySQL的事物，有什么特征，ACID是怎么实现的，隔离级别有几种，MVCC是怎么实现的，乐观锁，悲观锁
  - 缓存的热Key和大Key怎么处理
  - 简单说说kafka的架构，我要实现消息的顺序消费怎么办



#### 分布式

- [ ] 分布式事务了解
- [ ] 分布式事务讲⼀下？结合项⽬想讲的可靠消息⼀致性实现⽅案 + 最⼤努⼒送达通知⽅案，最后也提到了单应⽤多DB（JPA）、TCC事务以及适⽤场景。
- [ ] 分布式锁
- [ ] 缓存和数据库⼀致性如何保证的？谈到了分布式锁，那详细讲讲分布式锁实现？redis setnx、redisson、zookeeper
- [ ] 介绍平滑负载均衡算法，实现





#### other

- [ ] 对比 mysql redis http 连接池的实现
- [ ] 